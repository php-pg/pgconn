<?php

declare(strict_types=1);

namespace PhpPg\PgConn\ResultReader;

use Amp\ByteStream\ClosedException;
use Amp\Cancellation;
use Amp\CancelledException;
use PhpPg\PgConn\Exception\PgErrorException;
use PhpPg\PgConn\PgConn;
use PhpPg\PgProto3\Messages\BackendMessageInterface;
use PhpPg\PgProto3\Messages\CommandComplete;
use PhpPg\PgProto3\Messages\CommandTag;
use PhpPg\PgProto3\Messages\DataRow;
use PhpPg\PgProto3\Messages\FieldDescription;
use PhpPg\PgProto3\Messages\ReadyForQuery;
use PhpPg\PgProto3\Messages\RowDescription;

/**
 * Represents results of one SQL command in Extended Protocol
 */
class ResultReaderExtendedProtocol implements ResultReaderInterface
{
    private bool $closed = false;

    /**
     * @var array<string|null>
     */
    private array $rowValues = [];

    private ?CommandTag $commandTag = null;

    /**
     * @param PgConn $conn
     * @param array<FieldDescription>|null $fieldDescriptions
     */
    public function __construct(
        private PgConn $conn,
        private \Closure $releaseConn,
        private ?array $fieldDescriptions = null,
        private ?Cancellation $cancellation = null
    ) {
    }

    public function __destruct()
    {
        try {
            $this->close();
        } catch (\Throwable) {
            // silently ignore errors
        }
    }

    public function close(): void
    {
        if ($this->closed) {
            return;
        }

        // read remaining messages
        /* @phpstan-ignore-next-line */
        while (!$this->closed) {
            $this->receiveMessage();
        }
    }

    /**
     * @return array<?string>
     */
    public function getRowValues(): array
    {
        return $this->rowValues;
    }

    public function getCommandTag(): CommandTag
    {
        if ($this->commandTag === null) {
            throw new \LogicException('Keep calling nextRow until it returns false');
        }

        return $this->commandTag;
    }

    /**
     * Fetch all query results
     * WARNING: May consume a large amount of memory (depends on returned rows size)
     *
     * @return Result
     *
     * @throws ClosedException
     * @throws CancelledException
     * @throws PgErrorException
     */
    public function getResult(): Result
    {
        if ($this->closed) {
            throw new \LogicException('ResultReader is closed');
        }

        $rowValues = [];
        while ($this->nextRow()) {
            $rowValues[] = $this->rowValues;
        }

        if ($this->commandTag === null) {
            throw new \LogicException(
                'Something went wrong, commandTag is null, CommandCompleted message is not caught'
            );
        }

        return new Result(
            $this->fieldDescriptions ?? [],
            $rowValues,
            $this->commandTag,
        );
    }

    /**
     * Advances the ResultReader to the next row.
     *
     * @return bool true if a row is available
     *
     * @throws ClosedException
     * @throws CancelledException
     * @throws PgErrorException
     */
    public function nextRow(): bool
    {
        while (!$this->closed) {
            $msg = $this->receiveMessage($this->cancellation);

            switch ($msg::class) {
                case DataRow::class:
                    $this->rowValues = $msg->values;
                    return true;
            }
        }

        return false;
    }

    /**
     * @return BackendMessageInterface
     *
     * @throws ClosedException
     * @throws CancelledException
     * @throws PgErrorException
     */
    private function receiveMessage(?Cancellation $cancellation = null): BackendMessageInterface
    {
        if ($this->closed) {
            throw new \LogicException('ResultReader is closed');
        }

        try {
            $msg = $this->conn->receiveMessage($cancellation);
        } catch (ClosedException $e) {
            $this->free();

            throw $e;
        } catch (PgErrorException $e) {
            /**
             * In the event of an error, ErrorResponse is issued followed by ReadyForQuery.
             * All further processing of the query string is aborted by ErrorResponse
             * (even if more queries remained in it).
             * Note that this might occur partway through the sequence of messages generated by an individual query.
             */

            if ($e->pgError->severity !== 'FATAL') {
                // Finalize reading on Postgres error (put connection back to a valid state)
                $this->restoreConnectionState();
            }

            $this->free();

            throw $e;
        }

        switch ($msg::class) {
            // This message will only be intercepted if the interface sent the "Describe (P)" message
            case RowDescription::class:
                if ($this->fieldDescriptions === null) {
                    $this->fieldDescriptions = $msg->fields;
                }
                break;

            /**
             * From: Postgres Protocol Flow (53.2.2. Simple Query)
             *
             * Processing of the query string is complete.
             * A separate message is sent to indicate this because the query string might contain multiple SQL commands.
             * (CommandComplete marks the end of processing one SQL command, not the whole string.)
             */
            case CommandComplete::class:
                $this->commandTag = $msg->commandTag;
                break;

            case ReadyForQuery::class:
                $this->free();
                break;

            // TODO: Support portal suspended
            /**
             * If Execute terminates before completing the execution of a portal
             * (due to reaching a nonzero result-row count), it will send a PortalSuspended message;
             * the appearance of this message tells the frontend that another
             * Execute should be issued against the same portal to complete the operation.
             */
        }

        return $msg;
    }

    private function restoreConnectionState(): void
    {
        try {
            // TODO: Respect cancellation?
            while ($this->receiveMessage()::class !== ReadyForQuery::class) {
            }
        } catch (\Throwable) {
            // ignore exception
        }
    }

    private function free(): void
    {
        $this->closed = true;
        ($this->releaseConn)();
    }
}
